<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		 
			
  
    <meta name="twitter:card" content="summary"/>
    
      <meta name="twitter:image" content="https://kehux.win/images/avatar.png" />
    
  
  
  <meta name="twitter:title" content="Flow"/>
  <meta name="twitter:description" content="flow使用文档"/>
  
    <meta name="twitter:site" content="@your_twitter_id"/>
  
  
  
  
    <meta name="twitter:creator" content="@柚紫"/>
  



		
		<meta name="author" content="柚紫">
		<meta name="description" content="我最爱的人是我自己个儿。">
		<meta name="generator" content="Hugo 0.54.0" />
		<title>Flow &middot; 柚紫</title>
		<link rel="shortcut icon" href="https://kehux.win/images/favicon.ico">
		<link rel="stylesheet" href="https://kehux.win/css/style.css">
		<link rel="stylesheet" href="https://kehux.win/css/highlight.css">

		
		<link rel="stylesheet" href="https://kehux.win/css/font-awesome.min.css">
		

		
		<link href="https://kehux.win/index.xml" rel="alternate" type="application/rss+xml" title="柚紫" />
		

		
	</head>

    <body>
       <nav class="main-nav">
	
	
		<a href='https://kehux.win/'> <span class="arrow">←</span>Home</a>
	
	<a href='https://kehux.win/posts'>Archive</a>
	<a href='https://kehux.win/tags'>Tags</a>
	<a href='https://kehux.win/about'>About</a>

	

	
	<a class="cta" href="https://kehux.win/index.xml">Subscribe</a>
	
</nav>


        <section id="wrapper" class="post">
            <article>
                <header>
                    <h1>
                        Flow
                    </h1>
                    <h2 class="headline">
                    Mar 14, 2019 16:50
                    · 1094 words
                    · 6 minute read
                      <span class="tags">
                      
                      
                          
                              <a href="https://kehux.win/tags/react">React</a>
                          
                      
                      
                      </span>
                    </h2>
                </header>
                
                  
                    <div id="toc">
                      <nav id="TableOfContents">
<ul>
<li><a href="#安装">安装</a></li>
<li><a href="#开始">开始</a>
<ul>
<li><a href="#在react中配置flow">在React中配置Flow</a></li>
</ul></li>
<li><a href="#组件">组件</a>
<ul>
<li>
<ul>
<li>
<ul>
<li>
<ul>
<li><a href="#了解如何使用flow键入react类组件和无状态功能组件">了解如何使用Flow键入React类组件和无状态功能组件</a></li>
</ul></li>
</ul></li>
</ul></li>
<li><a href="#类组件">类组件</a></li>
<li><a href="#添加state">添加State</a></li>
<li><a href="#使用默认值">使用默认值</a></li>
<li><a href="#无状态功能组件">无状态功能组件</a></li>
<li><a href="#为方法组件设置默认值">为方法组件设置默认值</a></li>
</ul></li>
<li><a href="#事件处理">事件处理</a>
<ul>
<li>
<ul>
<li>
<ul>
<li><a href="#使用flow键入react事件处理">使用Flow键入React事件处理</a></li>
</ul></li>
</ul></li>
</ul></li>
<li><a href="#ref方法">ref方法</a>
<ul>
<li><a href="#如何使用flow写react的ref方法">如何使用Flow写React的ref方法</a></li>
</ul></li>
<li><a href="#children">Children</a>
<ul>
<li><a href="#学习如何使用flow严格规范子组件类型">学习如何使用Flow严格规范子组件类型</a></li>
<li><a href="#仅允许特定对象作为children">仅允许特定对象作为children</a></li>
<li><a href="#强制一个组件只能获得一个孩子">强制一个组件只能获得一个孩子。</a></li>
<li><a href="#关于输入方法和其他类型的children组件">关于输入方法和其他类型的children组件</a></li>
<li><a href="#使用-react-node-但没有一些原始类型-如字符串">使用<code>React.Node</code>但没有一些原始类型，如字符串。</a></li>
</ul></li>
<li><a href="#高阶组件">高阶组件</a>
<ul>
<li>
<ul>
<li>
<ul>
<li><a href="#学习如何使用flow去规范react的高阶组件">学习如何使用Flow去规范React的高阶组件</a></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
</nav>
                    </div>
                  
                
                <section id="post-body">
                    

<h1 id="安装">安装</h1>

<p>ONE: yarn add —dev babel-preset-flow</p>

<p>Two: 配置.babel 在presets 字段中添加 “flow”字段</p>

<p>THREE: yarn add —dev flow-bin</p>

<p>FOUR:设置eslint and webstorm , yarn add —dev eslint-plugin-flowtype</p>

<p>在webstorm 中设置，webstorm-preferences-&gt;Languages &amp; Frameworks-&gt;JavaScript,在这个面板中设置JavaScript language version 为flow,设置flow 路径，选择项目下的node_modules/flow-bin/vender/flow</p>

<p>Tip:如果路径下没有可以在flow-bin下选择其他文件</p>

<p>选择之后点击apply或者ok即可。</p>

<p>FIVE: yarn run flow init 类似eslint生成.flowconfig文件</p>

<p>SIX：使用前最后一步配置， yarn run flow，如果报错，设置配置文件。</p>

<p>常规配置ignore，option.忽略node_modules下的一些文件,一些包文件使用了flow，但有不规范的地方。option 文件设置文件后缀。</p>

<p>[ignore]</p>

<p>.<em>/node_modules/draft-js/.</em></p>

<p>[include]</p>

<p>[libs]</p>

<p>[lints]</p>

<p>[options]</p>

<p>module.file_ext=.scss</p>

<p>module.file_ext=.js</p>

<h1 id="开始">开始</h1>

<blockquote>
<p>开发者经常会将Flow和React搭配使用，因此Flow可以高效的输入常用的和高级的React模式变得非常重要。这篇指南将指导你如何使用Flow创建更安全的React应用。</p>

<p>在本指南中，我们将假定你了解React的基础知识并且着重考虑添加你已经熟悉的类型。我们将使用基于react-dom的例子，但是所有的模式也适用于其他环境像react-native。</p>

<h2 id="在react中配置flow">在React中配置Flow</h2>

<p>Flow可以和Babel更好的搭配，因此作为一个使用了Babel的React用户您无须花费更多时间去适应Flow。如果你需要通过Babel安装Flow，你可以参考这篇指南。</p>

<p>Babel跟Create React App亦可以开箱即用，仅需安装Flow并创建一个.flowconfig即可。</p>
</blockquote>

<h1 id="组件">组件</h1>

<h5 id="了解如何使用flow键入react类组件和无状态功能组件">了解如何使用Flow键入React类组件和无状态功能组件</h5>

<blockquote>
<p>将Flow输入React组件有着难以置信的作用。如果你使用了Flow，Flow将静态地确保你将使用组件按照它被设计的模式。</p>

<p>在早期React库中提供了PropTypes去执行基础运行检查。Flow是更强大的，当你滥用组件时，它可以实时告诉你在不运行代码的情况下。</p>

<p>这有许多从Flow中生成的Babel插件，例如[<a href="https://github.com/thejameskyle/babel-plugin-react-flow-props-to-prop-types"><code>babel-plugin-react-flow-props-to-prop-types</code></a>],如果你希望Flow同时进行静态检查和运行时检查。</p>

<h2 id="类组件">类组件</h2>

<p>在我们展示如何在React组件中使用FLow时，让我们先展示一下如何写React组件搭配React的prop types。你需要继承React.Component并且增加一个静态propTypes 属性</p>

<pre><code>import React from 'react';
import PropTypes from 'prop-types';

class MyComponent extends React.Component {
  static propTypes = {
    foo: PropTypes.number.isRequired,
    bar: PropTypes.string,
  };

  render() {
    return &lt;div&gt;{this.props.bar}&lt;/div&gt;;
  }
}
</code></pre>

<p>现在，我们将使用FLow写我们刚刚的组件</p>

<pre><code>import * as React from 'react';

type Props = {
  foo: number,
  bar?: string,
};

class MyComponent extends React.Component&lt;Props&gt; {
  render() {
    this.props.doesNotExist; // Error! You did not define a `doesNotExist` prop.

    return &lt;div&gt;{this.props.bar}&lt;/div&gt;;
  }
}

&lt;MyComponent foo={42} /&gt;;
</code></pre>

<p>我们移除了对prop-types包的依赖并且增加了Flow对象取名Props跟Prop types拥有一样的结构但是使用了Flow的静态类型语法。然后我们传递新的Props 类型作为类型参数到React.Component</p>

<p>现在如果你使用<MyComponent/>带有string类型的参数foo替代数字类型你将看到一个报错。</p>

<p>现在无论何时在React组件中你使用this.props，FLow都将把它视为我们定义的Props类型。</p>

<p><strong>注意：当你直接使用</strong></p>

<pre><code>extends React.Component&lt;{ foo: number, bar?: string }&gt;
</code></pre>

<p><strong>在同一行的定义方式时，可以不用再次使用Props 类型。</strong></p>

<p><strong>在这里，我们引入React作为命名空间</strong></p>

<pre><code>import * as React from 'react'
</code></pre>

<p><strong>替代之前默认引入方式</strong></p>

<pre><code>import React from 'react'
</code></pre>

<p><strong>当引入React作为Es模块时你可以使用任一样式，但是作为命名空间导入可以访问React的[<a href="https://flow.org/en/docs/react/types">utility types</a>]</strong></p>

<pre><code>React.Component&lt;Props, State&gt;
</code></pre>

<p><strong>通常带有两个参数，props和state，第二个参数是可选的。默认情况下它是undefined，你可以看到在上方例子中我们并没有引入State。我们将在后续章节中写更多State</strong></p>

<h2 id="添加state">添加State</h2>

<p>给你的React组件添加state类型然后创建一个新的对象类型在下面的例子中我们将它命名为State并把它作为第二个参数传递给React.Component</p>

<pre><code>import * as React from 'react';

type Props = { /* ... */ };

type State = {
  count: number,
};

class MyComponent extends React.Component&lt;Props, State&gt; {
  state = {
    count: 0,
  };

  componentDidMount() {
    setInterval(() =&gt; {
      this.setState(prevState =&gt; ({
        count: prevState.count + 1,
      }));
    }, 1000);
  }

  render() {
    return &lt;div&gt;Count: {this.state.count}&lt;/div&gt;;
  }
}

&lt;MyComponent /&gt;;
</code></pre>

<p>在上方例子中我们使用React setState()更新函数但你也可以将部分状态对象传递给setState()</p>

<h2 id="使用默认值">使用默认值</h2>

<p>React支持defaultProps的概念，你可以把它看作默认函数参数。当你创建一个没有包含默认prop的元素，React将会defaultProps替换相应的prop。Flow也支持这个概念，在你的类中声明默认类型并增加static defaultProps属性。</p>

<pre><code>import * as React from 'react';

type Props = {
  foo: number, // foo is required.
};

class MyComponent extends React.Component&lt;Props&gt; {
  static defaultProps = {
    foo: 42, // ...but we have a default prop for foo.
  };
}

// So we don't need to include foo.
&lt;MyComponent /&gt;
</code></pre>

<p>Flow将会从static defaultProps中推断默认类型，所以在使用时你不需要添加过多的注释。</p>

<p><strong>注意：你不需要在Props type中设置可以为空的属性，如果你又默认值，Flow将会确保foo是可选的。</strong></p>

<h2 id="无状态功能组件">无状态功能组件</h2>

<p>除了类之外，React还支持无状态功能组件。像键入组件一样键入一个方法：</p>

<pre><code>import * as React from 'react';

type Props = {
  foo: number,
  bar?: string,
};

function MyComponent(props: Props) {
  props.doesNotExist; // Error! You did not define a `doesNotExist` prop.

  return &lt;div&gt;{props.bar}&lt;/div&gt;;
}

&lt;MyComponent foo={42} /&gt;
</code></pre>

<h2 id="为方法组件设置默认值">为方法组件设置默认值</h2>

<p>在无状态组件中，React依旧支持默认值。跟类组件相似，默认值在无状态组件中生效不需要多余的注释。</p>

<pre><code>import * as React from 'react';

type Props = {
  foo: number, // foo is required.
};

function MyComponent(props: Props) {}

MyComponent.defaultProps = {
  foo: 42, // ...but we have a default prop for foo.
};

// So we don't need to include foo.
&lt;MyComponent /&gt;;
</code></pre>

<p><strong>注意：你不需要在Props type中设置可以为空的属性，如果你又默认值，Flow将会确保foo是可选的。</strong></p>
</blockquote>

<h1 id="事件处理">事件处理</h1>

<h4 id="使用flow键入react事件处理">使用Flow键入React事件处理</h4>

<blockquote>
<p>在React文档中“事件处理”章节中对于如何处理事件提供了几种不同的方法。如果你正在用Flow，我们建议你使用最简单的静态类型即属性初始定义方法。属性初始定义方法就像这样</p>

<pre><code>class MyComponent extends React.Component&lt;{}&gt; {
  handleClick = event =&gt; { /* ... */ };
}
</code></pre>

<p>进行事件处理，你或许会用到SyntheticEvent<T>类型，像这样：</p>

<pre><code>import * as React from 'react';

class MyComponent extends React.Component&lt;{}, { count: number }&gt; {
  handleClick = (event: SyntheticEvent&lt;HTMLButtonElement&gt;) =&gt; {
    // To access your button instance use `event.currentTarget`.
    (event.currentTarget: HTMLButtonElement);

    this.setState(prevState =&gt; ({
      count: prevState.count,
    }));
  };

  render() {
    return (
      &lt;div&gt;
        &lt;p&gt;Count: {this.state.count}&lt;/p&gt;
        &lt;button onClick={this.handleClick}&gt;
          Increment
        &lt;/button&gt;
      &lt;/div&gt;
    );
  }
}
</code></pre>

<p>这依旧还有很多具体的异步事件类型像<code>SyntheticKeyboardEvent&lt;T&gt;</code>, <code>SyntheticMouseEvent&lt;T&gt;</code>, 或者 <code>SyntheticTouchEvent&lt;T&gt;</code>。该<code>SyntheticEvent&lt;T&gt;</code>类型都采取单一的类型参数。事件处理程序所在的HTML元素的类型。</p>

<p>如果你不想添加元素实例的类型，你也可以使用 <code>SyntheticEvent</code>与*无*类型的参数，像这样：<code>SyntheticEvent&lt;&gt;</code>。</p>

<p>注意：要获取对象实例，像上面例子中的HTMLButtonElement，经常容易犯的错误是使用<code>event.target</code> 代替 <code>event.currentTarget</code>。我们之所以使用event.currentTarget是源于 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Examples#Example_5:_Event_Propagation">event propagation</a>.使用<code>event.target</code> 或许会得到错误的对象。</p>

<p>注意：React使用它自身的事件系统，所以使用SyntheticEvent类型代替像Event、KeyboardEvent和MouseEvent等DOM类型是至关重要的。</p>

<p>React提供的SyntheticEvent<T>以及相关的DOM事件：</p>

<ul>
<li><code>SyntheticEvent&lt;T&gt;</code> for <a href="https://developer.mozilla.org/en-US/docs/Web/API/Event">Event</a></li>
<li><code>SyntheticAnimationEvent&lt;T&gt;</code> for <a href="https://developer.mozilla.org/en-US/docs/Web/API/AnimationEvent">AnimationEvent</a></li>
<li><code>SyntheticCompositionEvent&lt;T&gt;</code> for <a href="https://developer.mozilla.org/en-US/docs/Web/API/CompositionEvent">CompositionEvent</a></li>
<li><code>SyntheticInputEvent&lt;T&gt;</code> for <a href="https://developer.mozilla.org/en-US/docs/Web/API/InputEvent">InputEvent</a></li>
<li><code>SyntheticUIEvent&lt;T&gt;</code> for <a href="https://developer.mozilla.org/en-US/docs/Web/API/UIEvent">UIEvent</a></li>
<li><code>SyntheticFocusEvent&lt;T&gt;</code> for <a href="https://developer.mozilla.org/en-US/docs/Web/API/FocusEvent">FocusEvent</a></li>
<li><code>SyntheticKeyboardEvent&lt;T&gt;</code> for <a href="https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent">KeyboardEvent</a></li>
<li><code>SyntheticMouseEvent&lt;T&gt;</code> for <a href="https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent">MouseEvent</a></li>
<li><code>SyntheticDragEvent&lt;T&gt;</code> for <a href="https://developer.mozilla.org/en-US/docs/Web/API/DragEvent">DragEvent</a></li>
<li><code>SyntheticWheelEvent&lt;T&gt;</code> for <a href="https://developer.mozilla.org/en-US/docs/Web/API/WheelEvent">WheelEvent</a></li>
<li><code>SyntheticTouchEvent&lt;T&gt;</code> for <a href="https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent">TouchEvent</a></li>
<li><code>SyntheticTransitionEvent&lt;T&gt;</code> for <a href="https://developer.mozilla.org/en-US/docs/Web/API/TransitionEvent">TransitionEvent</a></li>
<li>​</li>
</ul>
</blockquote>

<h1 id="ref方法">ref方法</h1>

<h2 id="如何使用flow写react的ref方法">如何使用Flow写React的ref方法</h2>

<blockquote>
<p>React允许你通过ref方法去抓取一个对象或者一个组件的实例。要使用ref方法需要在你的类中增加一个可能的实例类型并将实例分配到ref方法的属性中。</p>

<pre><code>import * as React from 'react';

class MyComponent extends React.Component&lt;{}&gt; {
  // The `?` here is important because you may not always have the instance.
  button: ?HTMLButtonElement;

  render() {
    return &lt;button ref={button =&gt; (this.button = button)}&gt;Toggle&lt;/button&gt;;
  }
}
</code></pre>

<p>?HTMLButtonElement 中?非常重要，上方例子中第一个参数ref将会是HTMLButtonElement | null，如果组件未挂载，React将会回调ref为空。同时，MyComponent中button属性不会被设置直到React的render方法执行完。在此之前button的ref属性将是undefined。为了避免这种情况的出现，使用？可以避免bug.</p>
</blockquote>

<h1 id="children">Children</h1>

<h2 id="学习如何使用flow严格规范子组件类型">学习如何使用Flow严格规范子组件类型</h2>

<blockquote>
<p>React对象可能有0、1、或者多个Children。使用Flow书写Children可以使你构建强大的APIs。</p>

<p>通常来说，当为你的React组件增加children类型时第一个去尝试的应该是<a href="https://flow.org/en/docs/react/types/#toc-react-node"><code>React.Node</code></a>.</p>

<p>像这样：</p>

<pre><code>import * as React from 'react';

type Props = {
  children?: React.Node,
};

function MyComponent(props: Props) {
  return &lt;div&gt;{props.children}&lt;/div&gt;;
}
</code></pre>

<p>注意：为了获得 <a href="https://flow.org/en/docs/react/types/#toc-react-node"><code>React.Node</code></a>类型，你需要使用<code>import * as React from 'react'</code> 代替<code>import React from 'react'</code> 。我们在 <a href="https://flow.org/en/docs/react/types/">React Type Reference</a>.中解释了为什么需要这样写的原因。</p>

<p>但是，如果您想使用React children API做任何更强大的功能，那么您将需要强烈的直觉关于React如何处理Children。在继续帮助建立直觉之前，我们来看几个例子。</p>

<p>如果您已经对React Children的工作有了很强的直觉，那么请随时<a href="https://flow.org/en/docs/react/children/#examples">跳到我们的示例，演示如何输入通常显示在React组件中的各种Children模式</a>。</p>

<p>我们的第一个实例是一个没有Children的对象:</p>

<pre><code>&lt;MyComponent /&gt;;

// which is the same as...
React.createElement(MyComponent, {});
</code></pre>

<p>如果你创造一个没有Children元素时，访问<code>props.children</code>将不会设置。如果您尝试访问<code>props.children</code>，将返回undefined。</p>

<p>那么如果只有一个Children会发生什么呢？</p>

<pre><code>&lt;MyComponent&gt;{1}{2}&lt;/MyComponent&gt;;

// which is the same as...
React.createElement(MyComponent, {}, 1, 2);
</code></pre>

<p>现在如果你传递两个值，props.children将会是一个数组。明确的说在这种情况下，<code>props.children</code> 将会是 <code>[1, 2]</code>.</p>

<p>多个children可能看起来是这样：</p>

<pre><code>&lt;MyComponent&gt;{'hello'} world&lt;/MyComponent&gt;;

// which is the same as...
React.createElement(MyComponent, {}, 'hello', ' world');
</code></pre>

<p>这种情况下， <code>props.children</code> 将会是数组 <code>['hello', ' world']</code>.</p>

<p>或者</p>

<pre><code>&lt;MyComponent&gt;{'hello'} &lt;strong&gt;world&lt;/strong&gt;&lt;/MyComponent&gt;;

// which is the same as...
React.createElement(
  MyComponent,
  {},
  'hello',
  ' ',
  React.createElement('strong', {}, 'world'),

</code></pre>

<p>这种情况下， <code>props.children</code> 将会是数组 <code>['hello', ' ', &lt;strong&gt;world&lt;/strong&gt;]</code>.</p>

<p>移到下一个问题。如果我们只有一个children并且它是数组将会发生什么？</p>

<pre><code>&lt;MyComponent&gt;{[1, 2]}&lt;/MyComponent&gt;;

// which is the same as...
React.createElement(MyComponent, {}, [1, 2]);
</code></pre>

<p>这遵从了同样的规则，当你仅有一个children时，props.children将会是确切的值。尽管 <code>[1, 2]</code>是一个数组但它是单一的值，props.children将是确切的值。也就是说 <code>props.children</code>将是数组[1, 2]，并不是被包含的数组。</p>

<p>这种情况经常出现，当你在如下情况中使用array.map()时。</p>

<pre><code>&lt;MyComponent&gt;
  {messages.map(message =&gt; &lt;strong&gt;{message}&lt;/strong&gt;)}
&lt;/MyComponent&gt;

// which is the same as...
React.createElement(
  MyComponent,
  {},
  messages.map(message =&gt; React.createElement('strong', {}, message)),
);
</code></pre>

<p>一个单独的数组被单独使用，那么如果我们有多个children并且都是数组呢？</p>

<pre><code>&lt;MyComponent&gt;{[1, 2]}{[3, 4]}&lt;/MyComponent&gt;;

// which is the same as...
React.createElement(MyComponent, {}, [1, 2], [3, 4]);
</code></pre>

<p>在这里props.children将会是数组中的数组，明确的说<code>props.children</code> 将会是 <code>[[1, 2], [3, 4]]</code>.</p>

<p>React Children规则应该被铭记，如果你没有children，props.children将不会被设置，如果你仅有一个，props.children将会被设定为确切的值，如果你有两个或是多个，props.children将会是这些值的一个数组。</p>

<p>注意：注意空格！ 就像下方所示：</p>

<pre><code>&lt;MyComponent&gt;{42}  &lt;/MyComponent&gt;
</code></pre>

<p>在有空格的情况下，等同于React.createElement(MyComponent, {}, 42, &lsquo; &lsquo;)。为什么空格会被传递？是因为在这种情况下<code>props.children</code> 将会是[42, &lsquo; &lsquo;]`而不是数字42.但是，如下是好的：</p>

<pre><code>&lt;MyComponent&gt;
  {42}
&lt;/MyComponent&gt;
</code></pre>

<p>它将编译到你所期望的： <code>React.createElement(MyComponent, {}, 42)</code>。</p>

<p>换行符之后的换行符和缩进被删除,但使用严格模式时，请注意children周围的空格或许会改变children的值。</p>

<p>注意： 当心注释！如下</p>

<pre><code>&lt;MyComponent&gt;
  // some comment...
  {42}
&lt;/MyComponent&gt;
</code></pre>

<p>这等同于React.createElement(MyComponent, {}, &lsquo;// some comment&hellip;&rsquo;, 42)。如何查看注释是否是对象的children？在这种情况下<code>props.children</code> 将会是 <code>['// some comment...', 42]</code>，包含了注释，使用JSX语法书写注释。</p>

<pre><code>&lt;MyComponent&gt;
  {/* some comment... */}
  {42}
&lt;/MyComponent&gt;
</code></pre>

<p>现在让我们看你如何使用直觉输入React组件多种多样的children</p>

<h2 id="仅允许特定对象作为children">仅允许特定对象作为children</h2>

<p>有时你仅希望一个特定组件作为children在你的React组件中。通常会在构建需要特定列子元素的表组件或者每个选项卡需要特定配置的选项卡栏时发生这种情况。使用此模式的一个这样的选项卡栏组件是React Native的<code>&lt;TabBarIOS&gt;</code>组件。</p>

<p><a href="http://facebook.github.io/react-native/docs/tabbarios.html">React Native的``组件</a>仅允许React元素子元素，而这些元素*必须*具有组件类型<code>&lt;TabBarIOS.Item&gt;</code>。你应该使用<code>&lt;TabBarIOS&gt;</code>像：</p>

<pre><code>&lt;TabBarIOS&gt;
  &lt;TabBarIOS.Item&gt;{/* ... */}&lt;/TabBarIOS.Item&gt;
  &lt;TabBarIOS.Item&gt;{/* ... */}&lt;/TabBarIOS.Item&gt;
  &lt;TabBarIOS.Item&gt;{/* ... */}&lt;/TabBarIOS.Item&gt;
&lt;/TabBarIOS&gt;
</code></pre>

<p>使用时不允许执行以下操作<code>&lt;TabBarIOS&gt;</code>：</p>

<pre><code>&lt;TabBarIOS&gt;
  &lt;TabBarIOS.Item&gt;{/* ... */}&lt;/TabBarIOS.Item&gt;
  &lt;TabBarIOS.Item&gt;{/* ... */}&lt;/TabBarIOS.Item&gt;
  &lt;View&gt;{/* ... */}&lt;/View&gt;
  &lt;SomeOtherComponent&gt;{/* ... */}&lt;/SomeOtherComponent&gt;
  &lt;TabBarIOS.Item&gt;{/* ... */}&lt;/TabBarIOS.Item&gt;
&lt;/TabBarIOS&gt;
</code></pre>

<p>看看我们如何添加<code>&lt;View&gt;</code>和<code>&lt;SomeOtherComponent&gt;</code>作为孩子 <code>&lt;TabBarIOS&gt;</code>？这是不允许的，<code>&lt;TabBarIOS&gt;</code>会抛出一个错误。我们如何确保Flow不允许这种模式？</p>

<pre><code>import * as React from 'react';

class TabBarIOSItem extends React.Component&lt;{}&gt; {
  // implementation...
}

type Props = {
  children: React.ChildrenArray&lt;React.Element&lt;typeof TabBarIOSItem&gt;&gt;,
};

class TabBarIOS extends React.Component&lt;Props&gt; {
  static Item = TabBarIOSItem;
  // implementation...
}

&lt;TabBarIOS&gt;
  &lt;TabBarIOS.Item&gt;{/* ... */}&lt;/TabBarIOS.Item&gt;
  &lt;TabBarIOS.Item&gt;{/* ... */}&lt;/TabBarIOS.Item&gt;
  &lt;TabBarIOS.Item&gt;{/* ... */}&lt;/TabBarIOS.Item&gt;
&lt;/TabBarIOS&gt;;
</code></pre>

<p>我们将设定props的好多React.ChildrenArray<React.Element<typeof TabBarIOSItem>&gt;类型将会保证<TabBarIOS>必须有一个children那就是TabBarIOS.Item对象</p>

<p>我们的<a href="https://flow.org/en/docs/react/types/">各类参考</a>有关于它们两者的信息 <a href="https://flow.org/en/docs/react/types/#toc-react-childrenarray"><code>React.ChildrenArray</code></a>和 <a href="https://flow.org/en/docs/react/types/#toc-react-element"><code>React.Element</code></a>。</p>

<p>注意：如果你想使用 <code>map()</code> 和 <code>forEach()</code> 这类的方法去处理 <a href="https://flow.org/en/docs/react/types/#toc-react-childrenarray"><code>React.ChildrenArray</code></a> 作为一个正常的JavaScript数组然后React可以提供</p>

<p><a href="https://facebook.github.io/react/docs/react-api.html#react.children"><code>React.Children</code> API</a> 去做这些事情。它具有这样的功能<code>React.Children.toArray(props.children)</code>，您可以将其视为<a href="https://flow.org/en/docs/react/types/#toc-react-childrenarray"><code>React.ChildrenArray</code></a> 平面数组。</p>

<h2 id="强制一个组件只能获得一个孩子">强制一个组件只能获得一个孩子。</h2>

<p>有时你想强制你的组件*只*接收一个孩子。您可以使用<a href="https://facebook.github.io/react/docs/react-api.html#react.children.only"><code>React.Children.only()</code>函数</a>来强制执行此约束，但您也可以在Flow中强制实施。为了做到这一点，你不会把孩子的类型包裹起来 <a href="https://flow.org/en/docs/react/types/#toc-react-childrenarray"><code>React.ChildrenArray</code></a>。像这样：</p>

<pre><code>import * as React from 'react';

type Props = {
  children: React.Element&lt;any&gt;,
};

function MyComponent(props: Props) {
  // implementation...
}

// Not allowed! You must have children.
&lt;MyComponent /&gt;;

// Not ok! We have multiple element children.
&lt;MyComponent&gt;
  &lt;div /&gt;
  &lt;div /&gt;
  &lt;div /&gt;
&lt;/MyComponent&gt;;

// This is ok. We have a single element child.
&lt;MyComponent&gt;
  &lt;div /&gt;
&lt;/MyComponent&gt;;
</code></pre>

<h2 id="关于输入方法和其他类型的children组件">关于输入方法和其他类型的children组件</h2>

<p>React 允许你传递任何值作为React组件的children。关于这个性能，这有许多创造性的用法比如使用一个如下所示的方法：</p>

<pre><code>&lt;MyComponent&gt;
  {data =&gt; (
    &lt;div&gt;{data.foo}&lt;/div&gt;
  )}
&lt;/MyComponent&gt;
</code></pre>

<p>React-router 4要求一个方法作为 <a href="https://reacttraining.com/react-router/core/api/Route/children-func">&lt;Router组件的Children</a>.你将提供一个方法作为children注入react-router像这样：</p>

<pre><code>&lt;Route path={to}&gt;
  {({ match }) =&gt; (
    &lt;li className={match ? 'active' : ''}&gt;
      &lt;Link to={to} {...rest}/&gt;
    &lt;/li&gt;
  )}
&lt;/Route&gt;
</code></pre>

<p>以下展示了如何使用Flow书写<Router>组件</p>

<pre><code>import * as React from 'react';

type Props = {
  children: (data: { match: boolean }) =&gt; React.Node,
  path: string,
  // other props...
};

class Route extends React.Component&lt;Props&gt; {
  // implementation...
}

&lt;Route path={to}&gt;
  {({ match }) =&gt; (
    &lt;li className={match ? 'active' : ''}&gt;
      &lt;Link to={to} {...rest}/&gt;
    &lt;/li&gt;
  )}
&lt;/Route&gt;;
</code></pre>

<p>Children 的类型是一个方法，传递许多对象类型并且返回 <a href="https://flow.org/en/docs/react/types/#toc-react-node"><code>React.Node</code></a> 是一个被React render任意类型值。一个children方法没有必要返回<a href="https://flow.org/en/docs/react/types/#toc-react-node"><code>React.Node</code></a>。它可以返回任意类型，但在这种情况下，<code>react-router</code>要呈现该<code>children</code> 函数返回的结果。</p>

<p>这种模式也不限于功能children。您也可以传递任意对象或类类型。</p>

<h2 id="使用-react-node-但没有一些原始类型-如字符串">使用<code>React.Node</code>但没有一些原始类型，如字符串。</h2>

<p><a href="https://flow.org/en/docs/react/types/#toc-react-node"><code>React.Node</code></a>是Children的一般类型，但有时您可能希望使用<a href="https://flow.org/en/docs/react/types/#toc-react-node"><code>React.Node</code></a>当排除一些原始类型，如字符串和数字。<a href="http://facebook.github.io/react-native/docs/view.html">例如，React Native <View> 组件</a>执行此操作。</p>

<p><a href="http://facebook.github.io/react-native/docs/view.html">React Native <View>组件</a>将允许任何原始值或任何React元素作为其子元素。但是，<code>&lt;View&gt;</code>不允许字符串或数字作为Children！您可以使用<a href="https://flow.org/en/docs/react/types/#toc-react-node"><code>React.Node</code></a>children类型<code>&lt;View&gt;</code>，但是<a href="https://flow.org/en/docs/react/types/#toc-react-node"><code>React.Node</code></a> 包括我们不想要的字符串<code>&lt;View&gt;</code>。所以我们需要创建自己的类型。</p>

<pre><code>import * as React from 'react';

type ReactNodeWithoutStrings = React.ChildrenArray&lt;

  | void

  | null

  | boolean

  | React.Element&lt;any&gt;

;

type Props = {

  children?: ReactNodeWithoutStrings,

  // other props...

};

class View extends React.Component&lt;Props&gt; {

  // implementation...

}
</code></pre>

<p><a href="https://flow.org/en/docs/react/types/#toc-react-childrenarray"><code>React.ChildrenArray</code></a>是一种类型，为儿童建立了React嵌套数组数据结构。<code>ReactNodeWithoutStrings</code>用作<a href="https://flow.org/en/docs/react/types/#toc-react-childrenarray"><code>React.ChildrenArray</code></a>一个任意嵌套的null，boolean或React元素的数组。</p>

<p><a href="https://flow.org/en/docs/react/types/#toc-react-element"><code>React.Element</code></a>是类似于<code>&lt;div/&gt;</code>或的React元素的类型<code>&lt;MyComponent/&gt;</code>。值得注意的元素与组件不一样！</p>

<blockquote>
<p><strong>注意：</strong>如果想要像&hellip;一样<code>map()</code>和/ <code>forEach()</code>或处理 <a href="https://flow.org/en/docs/react/types/#toc-react-childrenarray"><code>React.ChildrenArray</code></a>一个正常的JavaScript数组的方法，那么React就提供了<a href="https://facebook.github.io/react/docs/react-api.html#react.children"><code>React.Children</code>API</a>来做到这一点。它具有这样的功能<code>React.Children.toArray(props.children)</code>，您可以将其视为<a href="https://flow.org/en/docs/react/types/#toc-react-childrenarray"><code>React.ChildrenArray</code></a> 平面数组。</p>
</blockquote>
</blockquote>

<h1 id="高阶组件">高阶组件</h1>

<h4 id="学习如何使用flow去规范react的高阶组件">学习如何使用Flow去规范React的高阶组件</h4>

<p>高阶模式在React中很受欢迎，所以我们使用Flow提供有效的类型检查组件是很重要的。接下来之前，请确保你已经知道高阶组件或者去阅读 <a href="https://facebook.github.io/react/docs/higher-order-components.html">React documentation on higher-order components</a> 。</p>

<p>学习如何进行高阶组件类型检查，我们将以 <a href="https://github.com/acdlite/recompose">Recompose</a> 为例。 <a href="https://github.com/acdlite/recompose">Recompose</a> 是一个提供很多高阶组件的React库。让我们看一下，你如何使用 <a href="https://github.com/acdlite/recompose/blob/0ff7cf36f35e97dbd422a6924c7e7eddd47d0d34/docs/API.md#mapprops"><code>mapProps()</code> higher-order component from Recompose</a> 进行类型检查。</p>

<p>mapProps() 是一个将传入的props处理后输出的函数。你可以使用mapProps()想这样：</p>

                </section>
            </article>

            
                <a class="twitter" href="https://twitter.com/intent/tweet?text=https%3a%2f%2fkehux.win%2fposts%2fflow%2f - Flow by @your_twitter_id"><span class="icon-twitter"> tweet</span></a>

<a class="facebook" href="#" onclick="
    window.open(
      'https://www.facebook.com/sharer/sharer.php?u='+encodeURIComponent(location.href),
      'facebook-share-dialog',
      'width=626,height=436');
    return false;"><span class="icon-facebook-rect"> Share</span>
</a>

            

            
                <div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'your_disqus_short_name'; 

     
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>

            

            

            <footer id="footer">
    
        <div id="social">

	
	
    <a class="symbol" href="https://www.facebook.com/nodejh">
        <i class="fa fa-facebook-square"></i>
    </a>
    
    <a class="symbol" href="https://www.github.com/nodejh">
        <i class="fa fa-github-square"></i>
    </a>
    
    <a class="symbol" href="https://www.twitter.com/nodejh">
        <i class="fa fa-twitter-square"></i>
    </a>
    


</div>

    
    <p class="small">
    
       © Copyright 2019 <i class="fa fa-heart" aria-hidden="true"></i> 柚紫
    
    </p>
    <p class="small">
        Powered by <a href="http://www.gohugo.io/">Hugo</a> Theme By <a href="https://github.com/nodejh/hugo-theme-cactus-plus">nodejh</a>
    </p>
</footer>

        </section>

        <script src="https://kehux.win/js/jquery-3.3.1.min.js"></script>
<script src="https://kehux.win/js/main.js"></script>
<script src="https://kehux.win/js/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>




  
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'your_google_analytics_id', 'auto');
	
	ga('send', 'pageview');
}
</script>





    </body>
</html>
